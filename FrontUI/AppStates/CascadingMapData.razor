@using System.Collections.Generic
@using AshesMapBib.Models
@using FrontUI.FtpService
@using FrontUI.Helper.MapHelper
@inject IJSRuntime JS
@inject ResourceApiClient<Node> _nodes
@inject ResourceApiClient<NodePosition> _positions
@inject FTPConnection _ftp
<CascadingValue Value="this">
    @ChildContent
</CascadingValue>

@code {
    // List von ResourcePositionen, die die Daten enthalten
    public List<NodePositionView> NodePositionList { get; set; } = new List<NodePositionView>();
    public List<NodePositionView> AllNodePositionList { get; set; } = new();
    public NodePositionView SelectedPosition { get; set; } 
    [Parameter] public RenderFragment ChildContent { get; set;  }
    private bool _timer = true;
    public bool Timer
    {
        get => _timer;
        set
        {
            if (_timer != value)
            {
                _timer = value;

                if (_timer)
                {
                    // Timer wurde gestartet
                    StartedTimerAt = DateTime.Now;
                    TimeStopHistory.Add(MBetweenStartStop);
                }
                else
                {
                    // Timer wurde gestoppt
                    StoppedTimerAt = DateTime.Now;
                }
            }
        }
    }
    public DateTime? StartedTimerAt { get; set; }
    public DateTime? StoppedTimerAt { get; set; }
    public List<int> TimeStopHistory { get; set; } = new();
    private IEnumerable<string>? _timeLeftFilter = Enumerable.Empty<string>();

    public IEnumerable<string> timeLeftFilter
    {
        get => _timeLeftFilter ?? Enumerable.Empty<string>(); // Falls null, gib eine leere Liste zurück
        set
        {
            _timeLeftFilter = value ?? new List<string>(); // Falls null, initialisiere mit einer leeren Liste

            UpdateFilteredPosList();
            UpdateFilterByTime();
            UpdateMapMarkers();
        }
    }

    private IReadOnlyCollection<string> _selectedFilter = new List<string>();

    public IReadOnlyCollection<string> selectedFilter
    {
        get => _selectedFilter ?? new List<string>(); // Falls null, gib eine leere Liste zurück
        set
        {
            _selectedFilter = value ?? new List<string>(); // Falls null, initialisiere mit einer leeren Liste

            UpdateFilteredPosList();
            UpdateFilterByTime();
            UpdateMapMarkers();
        }
    }

    private async Task UpdateMapMarkers()
    {
        try
        {
            // Prüfe, ob removeCustomMarkers existiert und rufe es dann auf
            if (await JsFunctionExists("removeCustomMarkers"))
            {
                await JS.InvokeVoidAsync("removeCustomMarkers");
            }
            else
            {
                Console.WriteLine("❌ JS-Funktion 'removeCustomMarkers' nicht gefunden.");
            }

            foreach (var newSpot in FilteredPosList ?? Enumerable.Empty<NodePositionView>())
            {
                // Prüfe, ob addCustomMarker existiert, bevor es aufgerufen wird
                if (await JsFunctionExists("addCustomMarker"))
                {
                    await JS.InvokeVoidAsync("addCustomMarker", newSpot.Lat, newSpot.Lng, newSpot, newSpot.TimeLeft);
                }
                else
                {
                    Console.WriteLine("❌ JS-Funktion 'addCustomMarker' nicht gefunden.");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ Fehler beim Aufruf von JavaScript: {ex.Message}");
        }
    }

    // Öffentliche Methode zum manuellen Reload der Marker (von UI aus nutzbar)
    public async Task ReloadMapAsync()
    {
        try
        {
            if (await JsFunctionExists("removeCustomMarkers"))
                await JS.InvokeVoidAsync("removeCustomMarkers");

            NodeList = await GetAllNodes();
            AllNodePositionList = await GetNodePositions(includeGhosts: true);
            NodePositionList = AllNodePositionList.Where(e => !e.Ghost).ToList();

            UpdateFilteredPosList();
            UpdateFilterByTime();
            await UpdateMapMarkers();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ReloadMapAsync failed: {ex.Message}");
        }
        finally
        {
            StateHasChanged();
        }
    }
    private DotNetObjectReference<CascadingMapData>? objRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try { await JS.InvokeVoidAsync("initMap"); } catch { /* log */ }

            NodeList = await GetAllNodes();
            AllNodePositionList = await GetNodePositions(includeGhosts: true);
            NodePositionList = AllNodePositionList.Where(e => !e.Ghost).ToList();

            // Standard-Filter (ohne Ghosts)
            timeLeftFilter = new[] { "act", "<-1d" };
        }
    }
    // ✅ Hilfsmethode: Prüft, ob eine JS-Funktion existiert
    private async Task<bool> JsFunctionExists(string functionName)
    {
        try
        {
            return await JS.InvokeAsync<bool>("eval", $"typeof {functionName} !== 'undefined'");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Fehler bei der Überprüfung der Funktion: {ex.Message}");
            return false;
        }
    }

    public IEnumerable<NodePositionView> FilteredPosList { get; private set; }

    private void UpdateFilterByTime()
    {
        IEnumerable<NodePositionView> FilteredByTime = Enumerable.Empty<NodePositionView>();
        if (timeLeftFilter != null && timeLeftFilter.Any() && FilteredPosList.Any())
        {
            foreach (var timeSpan in timeLeftFilter)
            {
                switch (timeSpan.ToLowerInvariant())
                {
                    case "act":
                        FilteredByTime = FilteredByTime.Concat(FilteredPosList.Where(e => e.TimeLeft >= -3600)).Distinct();
                        break;
                    case "<-1d":
                        FilteredByTime = FilteredByTime.Concat(FilteredPosList.Where(e => e.TimeLeft <= -3600 && e.TimeLeft >= -86400)).Distinct();
                        break;
                    case ">-1d":
                        FilteredByTime = FilteredByTime.Concat(FilteredPosList.Where(e => e.TimeLeft <= -86400)).Distinct();
                        break;
                    case "ghost":
                        var ghosts = AllNodePositionList.Where(n => n.Ghost);
                        if (_selectedFilter != null && _selectedFilter.Any())
                            ghosts = ghosts.Where(MatchesSelectedFilters);
                        FilteredByTime = FilteredByTime.Concat(ghosts).Distinct();
                        break;
                }
            }
            FilteredPosList = FilteredByTime;
        }
    }

    private bool MatchesSelectedFilters(NodePositionView node) =>
        (_selectedFilter.Contains(node.Rarity) || !_selectedFilter.Any(f => IsRarity(f))) &&
        (_selectedFilter.Contains(node.Node.Type) || !_selectedFilter.Any(f => IsType(f))) &&
        (_selectedFilter.Contains(node.Node.Name) || !_selectedFilter.Any(f => IsName(f)));

    private bool IsRarity(string filter)
    {
        // Beispiel: Rarity-Werte sind Hex-Farben oder bekannte Strings
        return filter == "2c35be" || filter == "f3eb0a" || filter == "9b1cdc" || filter == "ff5700";
    }
    private bool IsType(string filter)
    {
        var knownTypes = AllNodePositionList.Select(n => n.Node.Type).Distinct();
        return knownTypes.Contains(filter);
    }
    private bool IsName(string filter)
    {
        var knownNames = AllNodePositionList.Select(n => n.Node.Name).Distinct();
        return knownNames.Contains(filter);
    }

    // Die Timer-Eigenschaft, die den Start- und Stoppzeitpunkt setzt


    // Berechnung der Zeitspanne zwischen Start und Stop (in Minuten)
    public int MBetweenStartStop => (int)(StoppedTimerAt - StartedTimerAt).GetValueOrDefault().TotalSeconds;

    public string ResType { get; set; } = "";
    // Methode zum Hinzufügen einer neuen ResourcePosition
    public async Task AddNode(Node toAdd)
    {
        toAdd.Id = Guid.NewGuid().ToString();
        NodeList.Add(toAdd);
        await _nodes.CreateAsync(toAdd, "/node");
    }
    public async Task AddResourcePosition(NodePositionView node)
    {
        // Füge die Position zur Liste hinzu
        NodePositionList.Add(node);

        // Falls im node.Image ein Base64-String enthalten ist, verarbeite diesen:
        if (!string.IsNullOrEmpty(node.Image))
        {
            // Generiere einen eindeutigen Dateinamen (GUID.png)
            var fileName = Guid.NewGuid().ToString() + ".png";

            // Erstelle eine Instanz des FileUploaders und lade die Datei per FTP hoch
            var uploader = new FileUploader();
            uploader.UploadBase64FileToRemote(node.Image, fileName);

            // Ersetze den Base64-String durch den Dateinamen, sodass in der Datenbank
            // der Dateiname gespeichert wird und nicht der ganze Base64-String
            node.Image = fileName;
        }

        // Füge den Marker in der Karte hinzu
        await JS.InvokeVoidAsync("addCustomMarker", node.Lat, node.Lng, node, node.TimeLeft);

        if (selectedFilter == null || !selectedFilter.Contains(node.Node.Type))
        {
            var test = node.Node.Type.ToList();
        }

        // Erstelle einen neuen NodePosition-Eintrag für den Server, wobei nun im Image-Feld der Dateiname steht
        var postNode = new NodePosition
            {
                Id = Guid.NewGuid().ToString(),
                Node = null,
                ResourceId = node.Node.Id,
                Description = node.Description,
                Lat = node.Lat,
                Lng = node.Lng,
                Rarity = node.Rarity,
                Image = node.Image,
                LastHarvest = node.LastHarvest,
                TimerMod = 0
            };
        await _positions.CreateAsync(postNode, "/nodeposition");

        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        base.OnInitialized();
    }

    public async Task<List<NodePositionView>> GetNodePositions(bool includeGhosts = false)
    {
        var result = new List<NodePositionView>();
        var endpoint = includeGhosts ? "/nodeposition" : "/nodeposition?ghost=eq.false";
        var fromClient = await _positions.GetAllAsync(endpoint);

        foreach (var spot in fromClient)
        {
            var node = NodeList.FirstOrDefault(e => e.Id == spot.ResourceId);

            var newSpot = new NodePositionView
            {
                Id = spot.Id,
                Node = node,
                ResourceId = node?.Id ?? spot.ResourceId,
                Description = spot.Description,
                Lat = spot.Lat,
                Lng = spot.Lng,
                Rarity = spot.Rarity,
                Image = spot.Image,
                LastHarvest = spot.LastHarvest,
                TimerMod = 0,
                Ghost = spot.Ghost
            };

            result.Add(newSpot);
        }

        return result;
    }
    public async Task SaveNode(NodePosition node)
    { 

    }
    public async Task UpdateNodePosition(NodePositionView nodeView)
    {
        var putNode = new NodePosition
        {
            Id = nodeView.Id,
            Node = null,
            ResourceId = nodeView.Node.Id,
            Description = nodeView.Description,
            Lat = nodeView.Lat,
            Lng = nodeView.Lng,
            Rarity = nodeView.Rarity,
            Image = nodeView.Image,
            LastHarvest = nodeView.LastHarvest,
            Ghost = nodeView.Ghost,
            TimerMod = 0
        };

        await _positions.UpdateAsync(putNode.Id, putNode, $"/nodeposition?id=eq.");

        // All-Liste aktualisieren
        var inAll = AllNodePositionList.FirstOrDefault(e => e.Id == nodeView.Id);
        if (inAll != null)
        {
            inAll.Description = nodeView.Description;
            inAll.Lat = nodeView.Lat;
            inAll.Lng = nodeView.Lng;
            inAll.Rarity = nodeView.Rarity;
            inAll.Image = nodeView.Image;
            inAll.LastHarvest = nodeView.LastHarvest;
            inAll.Ghost = nodeView.Ghost;
            inAll.Node = nodeView.Node;
        }
        else
        {
            AllNodePositionList.Add(nodeView);
        }

        // Aktive Liste (ohne Ghosts) synchronisieren
        var inActive = NodePositionList.FirstOrDefault(e => e.Id == nodeView.Id);
        if (nodeView.Ghost)
        {
            if (inActive != null) NodePositionList.Remove(inActive);
        }
        else
        {
            if (inActive != null)
            {
                inActive.Description = nodeView.Description;
                inActive.Lat = nodeView.Lat;
                inActive.Lng = nodeView.Lng;
                inActive.Rarity = nodeView.Rarity;
                inActive.Image = nodeView.Image;
                inActive.LastHarvest = nodeView.LastHarvest;
                inActive.Ghost = nodeView.Ghost;
                inActive.Node = nodeView.Node;
            }
            else
            {
                NodePositionList.Add(nodeView);
            }
        }

        UpdateFilteredPosList();
        UpdateFilterByTime();
        await UpdateMapMarkers();
    }

    public async Task DeleteNodePositionComplete(NodePosition position)
    {
        await _positions.DeleteAsync(position.Id, "/nodeposition?id=eq."); ;
    }

    public static string _selectedPositionId { get; set; }

    public List<Node> NodeList { get; set; } = new();
    public async Task<List<Node>> GetAllNodes()
    {
        List<Node> blob = new();
        blob = await _nodes.GetAllAsync("/node");
        return blob;
    }
    public async Task CreateNode(Node node){

    }
    // Action-Delegat, um Funktionen zu registrieren, die bei Änderungen an der ID ausgeführt werden
    public static Action<string> OnNodeIdChanged;

    // Methode, um die ID zu ändern und die Action auszulösen
    public void UpdateSelectedPositionId(string newId)
    {
        SelectedPositionId = newId;


        // Wenn ein Listener für das Ereignis existiert, rufen wir ihn auf
        OnNodeIdChanged?.Invoke(newId);
    }
    public string SelectedPositionId { get; set; }

    // Der Listener für das Event, das von MapHandler ausgelöst wird
    protected override void OnInitialized()
    {
        // Abonniere das Event von MapHandler
        MapHandler.OnNodeIdChanged += HandleNodeIdChanged;
    }

    // Diese Methode wird aufgerufen, wenn die NodeId geändert wird
    private void HandleNodeIdChanged(string newId)
    {
        // Aktualisiere die Instanzvariable mit der neuen ID
        SelectedPositionId = newId;
        if (NodePositionList != null)
        {
            SelectedPosition = NodePositionList.FirstOrDefault(e => e.Id == SelectedPositionId);
            StateHasChanged();

        }
        // UI aktualisieren
       
    }

    // Diese Methode sucht nach der NodePosition basierend auf der ID und aktualisiert die Liste

    // Event-Handler abmelden, wenn die Komponente zerstört wird
    public void Dispose()
    {
        MapHandler.OnNodeIdChanged -= HandleNodeIdChanged;
    }


    private void UpdateFilteredPosList()
    {
        // Beispiel-Implementierung: Filtert die NodePositionList anhand der ausgewählten Filter
        if (NodePositionList == null)
        {
            FilteredPosList = Enumerable.Empty<NodePositionView>();
            return;
        }

        IEnumerable<NodePositionView> filtered = NodePositionList;

        if (_selectedFilter != null && _selectedFilter.Any())
        {
            filtered = filtered.Where(MatchesSelectedFilters);
        }

        FilteredPosList = filtered.ToList();
    }
}
