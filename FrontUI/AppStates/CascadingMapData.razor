@using System.Collections.Generic
@using AshesMapBib.Models
@using FrontUI.FtpService
@using FrontUI.Helper.MapHelper
@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject ResourceApiClient<Node> _nodes
@inject ResourceApiClient<NodePosition> _positions
@inject FTPConnection _ftp
<CascadingValue Value="this">
    @ChildContent
</CascadingValue>

@code {
    // Merkliste: letzte ausgewählte Resource pro Typ (nur Session-weit)
    public Dictionary<string, string> LastSelectedResourcePerType { get; set; } = new();
    public Node? GetLastNodeForType(string? type)
    {
        if (string.IsNullOrWhiteSpace(type)) return null;
        if (LastSelectedResourcePerType.TryGetValue(type, out var id))
            return NodeList.FirstOrDefault(n => n.Id == id && n.Type == type);
        return null;
    }
    public void SetLastNodeForType(string? type, string? resourceId)
    {
        if (string.IsNullOrWhiteSpace(type) || string.IsNullOrWhiteSpace(resourceId)) return;
        LastSelectedResourcePerType[type] = resourceId;
    }

    // Favoriten (AlertSet) persistent halten (localStorage)
    public HashSet<string> FavoriteNodePositionIds { get; set; } = new();
    private const string FavoriteStorageKey = "favoriteNodePositions";
    public async Task LoadFavoritesAsync()
    {
        try
        {
            var json = await JS.InvokeAsync<string>("localStorage.getItem", FavoriteStorageKey);
            if (!string.IsNullOrWhiteSpace(json))
            {
                var favs = System.Text.Json.JsonSerializer.Deserialize<HashSet<string>>(json);
                if (favs != null)
                    FavoriteNodePositionIds = favs;
            }
        }
        catch { /* ignore */ }
    }
    private async Task PersistFavoritesAsync()
    {
        try
        {
            var json = System.Text.Json.JsonSerializer.Serialize(FavoriteNodePositionIds);
            await JS.InvokeVoidAsync("localStorage.setItem", FavoriteStorageKey, json);
        }
        catch { /* ignore */ }
    }
    public void SetFavorite(string id, bool isFavorite)
    {
        if (string.IsNullOrWhiteSpace(id)) return;
        if (isFavorite) FavoriteNodePositionIds.Add(id); else FavoriteNodePositionIds.Remove(id);
        _ = PersistFavoritesAsync();
        // sofort auf aktuelle Liste anwenden
        var spot = AllNodePositionList.FirstOrDefault(e => e.Id == id);
        if (spot != null) spot.AlertSet = isFavorite;
    }
    private void ApplyFavorites()
    {
        if (FavoriteNodePositionIds == null || FavoriteNodePositionIds.Count == 0) return;
        foreach (var pos in AllNodePositionList)
        {
            if (FavoriteNodePositionIds.Contains(pos.Id))
                pos.AlertSet = true;
        }
        foreach (var pos in NodePositionList)
        {
            if (FavoriteNodePositionIds.Contains(pos.Id))
                pos.AlertSet = true;
        }
    }
    // Automatisches Deaktivieren von Favoriten nach > 1 Tag überfällig
    public void AutoDeactivateExpiredFavorites()
    {
        if (AllNodePositionList == null || AllNodePositionList.Count == 0) return;
        const int dayInSeconds = 86400;
        var expired = AllNodePositionList
            .Where(p => p.AlertSet && p.TimeLeft <= -dayInSeconds)
            .Select(p => p.Id)
            .Distinct()
            .ToList();
        if (expired.Count == 0) return;

        foreach (var id in expired)
        {
            FavoriteNodePositionIds.Remove(id);
            var pAll = AllNodePositionList.FirstOrDefault(x => x.Id == id);
            if (pAll != null) pAll.AlertSet = false;
            var pAct = NodePositionList.FirstOrDefault(x => x.Id == id);
            if (pAct != null) pAct.AlertSet = false;
        }
        _ = PersistFavoritesAsync();
    }

    // List von ResourcePositionen, die die Daten enthalten
    public List<NodePositionView> NodePositionList { get; set; } = new List<NodePositionView>();
    public List<NodePositionView> AllNodePositionList { get; set; } = new();
    public NodePositionView SelectedPosition { get; set; } 
    [Parameter] public RenderFragment ChildContent { get; set;  }
    private bool _timer = true;
    public bool Timer
    {
        get => _timer;
        set
        {
            if (_timer != value)
            {
                _timer = value;

                if (_timer)
                {
                    // Timer wurde gestartet
                    StartedTimerAt = DateTime.Now;
                    TimeStopHistory.Add(MBetweenStartStop);
                }
                else
                {
                    // Timer wurde gestoppt
                    StoppedTimerAt = DateTime.Now;
                }
            }
        }
    }
    public DateTime? StartedTimerAt { get; set; }
    public DateTime? StoppedTimerAt { get; set; }
    public List<int> TimeStopHistory { get; set; } = new();
    private IEnumerable<string>? _timeLeftFilter = Enumerable.Empty<string>();

    public IEnumerable<string> timeLeftFilter
    {
        get => _timeLeftFilter ?? Enumerable.Empty<string>(); // Falls null, gib eine leere Liste zurück
        set
        {
            _timeLeftFilter = value ?? new List<string>(); // Falls null, initialisiere mit einer leeren Liste

            UpdateFilteredPosList();
            UpdateFilterByTime();
            UpdateMapMarkers();
        }
    }

    private IReadOnlyCollection<string> _selectedFilter = new List<string>();

    public IReadOnlyCollection<string> selectedFilter
    {
        get => _selectedFilter ?? new List<string>(); // Falls null, gib eine leere Liste zurück
        set
        {
            _selectedFilter = value ?? new List<string>(); // Falls null, initialisiere mit einer leeren Liste

            UpdateFilteredPosList();
            UpdateFilterByTime();
            UpdateMapMarkers();
        }
    }

    private async Task UpdateMapMarkers()
    {
        try
        {
            // Prüfe, ob removeCustomMarkers existiert und rufe es dann auf
            if (await JsFunctionExists("removeCustomMarkers"))
            {
                await JS.InvokeVoidAsync("removeCustomMarkers");
            }
            else
            {
                Console.WriteLine("❌ JS-Funktion 'removeCustomMarkers' nicht gefunden.");
            }

            foreach (var newSpot in FilteredPosList ?? Enumerable.Empty<NodePositionView>())
            {
                // Prüfe, ob addCustomMarker existiert, bevor es aufgerufen wird
                if (await JsFunctionExists("addCustomMarker"))
                {
                    await JS.InvokeVoidAsync("addCustomMarker", newSpot.Lat, newSpot.Lng, newSpot, newSpot.TimeLeft);
                }
                else
                {
                    Console.WriteLine("❌ JS-Funktion 'addCustomMarker' nicht gefunden.");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ Fehler beim Aufruf von JavaScript: {ex.Message}");
        }
    }

    // Öffentliche Methode zum manuellen Reload der Marker (von UI aus nutzbar)
    public async Task ReloadMapAsync()
    {
        try
        {
            if (await JsFunctionExists("removeCustomMarkers"))
                await JS.InvokeVoidAsync("removeCustomMarkers");

            // Favoriten behalten (FavoriteNodePositionIds bereits geladen)
            NodeList = await GetAllNodes();
            AllNodePositionList = await GetNodePositions(includeGhosts: true);
            NodePositionList = AllNodePositionList.Where(e => !e.Ghost).ToList();

            ApplyFavorites();
            AutoDeactivateExpiredFavorites();
            UpdateFilteredPosList();
            UpdateFilterByTime();
            await UpdateMapMarkers();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ReloadMapAsync failed: {ex.Message}");
        }
        finally
        {
            StateHasChanged();
        }
    }
    private DotNetObjectReference<CascadingMapData>? objRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try { await JS.InvokeVoidAsync("initMap"); } catch { /* log */ }

            try { await JS.InvokeVoidAsync("initMap"); } catch { }
            await LoadFavoritesAsync();
            NodeList = await GetAllNodes();
            AllNodePositionList = await GetNodePositions(includeGhosts: true);
            NodePositionList = AllNodePositionList.Where(e => !e.Ghost).ToList();

            // Standard-Filter (ohne Ghosts)
            timeLeftFilter = new[] { "act", "<-1d" };
            ApplyFavorites();
            AutoDeactivateExpiredFavorites();
            timeLeftFilter = new[] { "act", "<-1d" }; // Standard-Filter (ohne Ghosts)
        }

        // Bei Auswahl: nur zur Liste scrollen; keine Karten-Zentrierung hier
        if (SelectedPosition != null)
        {
            try
            {
                await JS.InvokeVoidAsync("scrollToElementId", $"node-row-{SelectedPosition.Id}");
            }
            catch { }
            try { await JS.InvokeVoidAsync("scrollToElementId", $"node-row-{SelectedPosition.Id}"); } catch { }
        }
    }
    // ✅ Hilfsmethode: Prüft, ob eine JS-Funktion existiert
    private async Task<bool> JsFunctionExists(string functionName)
    {
        try
        {
            return await JS.InvokeAsync<bool>("eval", $"typeof {functionName} !== 'undefined'");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Fehler bei der Überprüfung der Funktion: {ex.Message}");
            return false;
        }
    }

    public IEnumerable<NodePositionView> FilteredPosList { get; private set; }

    private void UpdateFilterByTime()
    {
        if (timeLeftFilter == null || !timeLeftFilter.Any())
            return;

        // Basis: die bereits nach Rarity/Type/Name gefilterten Nicht-Ghosts
        var baseSet = FilteredPosList ?? Enumerable.Empty<NodePositionView>();
        IEnumerable<NodePositionView> result = Enumerable.Empty<NodePositionView>();

        foreach (var timeSpan in timeLeftFilter)
        {
            switch (timeSpan.ToLowerInvariant())
            {
                case "act":
                    result = result.Concat(baseSet.Where(e => e.TimeLeft >= -3600)).Distinct();
                    break;
                case "<-1d":
                    result = result.Concat(baseSet.Where(e => e.TimeLeft <= -3600 && e.TimeLeft >= -86400)).Distinct();
                    break;
                case ">-1d":
                    result = result.Concat(baseSet.Where(e => e.TimeLeft <= -86400)).Distinct();
                    break;
                case "ghost":
                    // Ghosts kommen aus der All-Liste, unabhängig davon, ob baseSet leer ist
                    var ghosts = AllNodePositionList.Where(n => n.Ghost);
                    if (_selectedFilter != null && _selectedFilter.Any())
                        ghosts = ghosts.Where(MatchesSelectedFilters);
                    result = result.Concat(ghosts).Distinct();
                    break;
            }
        }

        FilteredPosList = result.ToList();
    }

    private bool MatchesSelectedFilters(NodePositionView node) =>
        (_selectedFilter.Contains(node.Rarity) || !_selectedFilter.Any(f => IsRarity(f))) &&
        (_selectedFilter.Contains(node.Node.Type) || !_selectedFilter.Any(f => IsType(f))) &&
        (_selectedFilter.Contains(node.Node.Name) || !_selectedFilter.Any(f => IsName(f)));

    // bekannte Rarities inkl. Unknown
    private static readonly HashSet<string> KnownRarities = new(StringComparer.OrdinalIgnoreCase)
    {
        "808080", // Unknown (grau)
        "2c35be", // Rare
        "f3eb0a", // Hero
        "9b1cdc", // Epic
        "ff5700"  // Legi
    };

    private bool IsRarity(string filter)
    {
        return !string.IsNullOrWhiteSpace(filter) && KnownRarities.Contains(filter);
    }
    private bool IsType(string filter)
    {
        var knownTypes = AllNodePositionList.Select(n => n.Node.Type).Distinct();
        return knownTypes.Contains(filter);
    }
    private bool IsName(string filter)
    {
        var knownNames = AllNodePositionList.Select(n => n.Node.Name).Distinct();
        return knownNames.Contains(filter);
    }

    // Die Timer-Eigenschaft, die den Start- und Stoppzeitpunkt setzt


    // Berechnung der Zeitspanne zwischen Start und Stop (in Minuten)
    public int MBetweenStartStop => (int)(StoppedTimerAt - StartedTimerAt).GetValueOrDefault().TotalSeconds;

    public string ResType { get; set; } = "";
    // Methode zum Hinzufügen einer neuen ResourcePosition
    public async Task AddNode(Node toAdd)
    {
        toAdd.Id = Guid.NewGuid().ToString();
        NodeList.Add(toAdd);
        await _nodes.CreateAsync(toAdd, "/node");
    }
    public async Task AddResourcePosition(NodePositionView node)
    {
        // Füge die Position zur Liste hinzu
        NodePositionList.Add(node);

        // Falls im node.Image ein Base64-String enthalten ist, verarbeite diesen:
        if (!string.IsNullOrEmpty(node.Image))
        {
            // Generiere einen eindeutigen Dateinamen (GUID.png)
            var fileName = Guid.NewGuid().ToString() + ".png";

            // Erstelle eine Instanz des FileUploaders und lade die Datei per FTP hoch
            var uploader = new FileUploader();
            uploader.UploadBase64FileToRemote(node.Image, fileName);

            // Ersetze den Base64-String durch den Dateinamen, sodass in der Datenbank
            // der Dateiname gespeichert wird und nicht der ganze Base64-String
            node.Image = fileName;
        }

        // Füge den Marker in der Karte hinzu
        await JS.InvokeVoidAsync("addCustomMarker", node.Lat, node.Lng, node, node.TimeLeft);

        if (selectedFilter == null || !selectedFilter.Contains(node.Node.Type))
        {
            var test = node.Node.Type.ToList();
        }

        // Erstelle einen neuen NodePosition-Eintrag für den Server, wobei nun im Image-Feld der Dateiname steht
        var postNode = new NodePosition
            {
                Id = Guid.NewGuid().ToString(),
                Node = null,
                ResourceId = node.Node.Id,
                Description = node.Description,
                Lat = node.Lat,
                Lng = node.Lng,
                Rarity = node.Rarity,
                Image = node.Image,
                LastHarvest = node.LastHarvest,
                TimerMod = 0
            };
        await _positions.CreateAsync(postNode, "/nodeposition");

        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        base.OnInitialized();
    }

    public async Task<List<NodePositionView>> GetNodePositions(bool includeGhosts = false)
    {
        var result = new List<NodePositionView>();
        var endpoint = includeGhosts ? "/nodeposition" : "/nodeposition?ghost=eq.false";
        var fromClient = await _positions.GetAllAsync(endpoint);

        foreach (var spot in fromClient)
        {
            var node = NodeList.FirstOrDefault(e => e.Id == spot.ResourceId);

            var newSpot = new NodePositionView
            {
                Id = spot.Id,
                Node = node,
                ResourceId = node?.Id ?? spot.ResourceId,
                Description = spot.Description,
                Lat = spot.Lat,
                Lng = spot.Lng,
                Rarity = spot.Rarity,
                Image = spot.Image,
                LastHarvest = spot.LastHarvest,
                TimerMod = 0,
                Ghost = spot.Ghost,
                AlertSet = FavoriteNodePositionIds.Contains(spot.Id)
            };

            result.Add(newSpot);
        }

        return result;
    }
    public async Task SaveNode(NodePosition node)
    { 

    }
    public async Task UpdateNodePosition(NodePositionView nodeView)
    {
        var putNode = new NodePosition
        {
            Id = nodeView.Id,
            Node = null,
            ResourceId = nodeView.Node.Id,
            Description = nodeView.Description,
            Lat = nodeView.Lat,
            Lng = nodeView.Lng,
            Rarity = nodeView.Rarity,
            Image = nodeView.Image,
            LastHarvest = nodeView.LastHarvest,
            Ghost = nodeView.Ghost,
            TimerMod = 0
        };

        await _positions.UpdateAsync(putNode.Id, putNode, $"/nodeposition?id=eq.");

        // All-Liste aktualisieren
        var inAll = AllNodePositionList.FirstOrDefault(e => e.Id == nodeView.Id);
        if (inAll != null)
        {
            inAll.Description = nodeView.Description;
            inAll.Lat = nodeView.Lat;
            inAll.Lng = nodeView.Lng;
            inAll.Rarity = nodeView.Rarity;
            inAll.Image = nodeView.Image;
            inAll.LastHarvest = nodeView.LastHarvest;
            inAll.Ghost = nodeView.Ghost;
            inAll.Node = nodeView.Node;
            inAll.AlertSet = nodeView.AlertSet;
        }
        else
        {
            AllNodePositionList.Add(nodeView);
        }

        // Aktive Liste (ohne Ghosts) synchronisieren
        var inActive = NodePositionList.FirstOrDefault(e => e.Id == nodeView.Id);
        if (nodeView.Ghost)
        {
            if (inActive != null) NodePositionList.Remove(inActive);
        }
        else
        {
            if (inActive != null)
            {
                inActive.Description = nodeView.Description;
                inActive.Lat = nodeView.Lat;
                inActive.Lng = nodeView.Lng;
                inActive.Rarity = nodeView.Rarity;
                inActive.Image = nodeView.Image;
                inActive.LastHarvest = nodeView.LastHarvest;
                inActive.Ghost = nodeView.Ghost;
                inActive.Node = nodeView.Node;
                inActive.AlertSet = nodeView.AlertSet;
            }
            else
            {
                NodePositionList.Add(nodeView);
            }
        }
        if (nodeView.AlertSet)
            FavoriteNodePositionIds.Add(nodeView.Id);
        else
            FavoriteNodePositionIds.Remove(nodeView.Id);
        _ = PersistFavoritesAsync();

        UpdateFilteredPosList();
        UpdateFilterByTime();
        await UpdateMapMarkers();
    }

    public async Task DeleteNodePositionComplete(NodePosition position)
    {
        await _positions.DeleteAsync(position.Id, "/nodeposition?id=eq."); ;
    }

    public static string _selectedPositionId { get; set; }

    public List<Node> NodeList { get; set; } = new();
    public async Task<List<Node>> GetAllNodes()
    {
        List<Node> blob = new();
        blob = await _nodes.GetAllAsync("/node");
        return blob;
    }
    public async Task CreateNode(Node node){

    }
    // Action-Delegat, um Funktionen zu registrieren, die bei Änderungen an der ID ausgeführt werden
    public static Action<string> OnNodeIdChanged;

    // Methode, um die ID zu ändern und die Action auszulösen
    public void UpdateSelectedPositionId(string newId)
    {
        SelectedPositionId = newId;


        // Wenn ein Listener für das Ereignis existiert, rufen wir ihn auf
        OnNodeIdChanged?.Invoke(newId);
    }
    public string SelectedPositionId { get; set; }

    // Der Listener für das Event, das von MapHandler ausgelöst wird
    protected override void OnInitialized()
    {
        // Abonniere das Event von MapHandler
        MapHandler.OnNodeIdChanged += HandleNodeIdChanged;
    }

    // Diese Methode wird aufgerufen, wenn die NodeId geändert wird
    private void HandleNodeIdChanged(string newId)
    {
        // Aktualisiere die Instanzvariable mit der neuen ID
        SelectedPositionId = newId;
        if (NodePositionList != null)
        {
            SelectedPosition = NodePositionList.FirstOrDefault(e => e.Id == SelectedPositionId);
            StateHasChanged();

        }
        // UI aktualisieren
       
    }

    // Diese Methode sucht nach der NodePosition basierend auf der ID und aktualisiert die Liste

    // Event-Handler abmelden, wenn die Komponente zerstört wird
    public void Dispose()
    {
        MapHandler.OnNodeIdChanged -= HandleNodeIdChanged;
    }


    private void UpdateFilteredPosList()
    {
        // Beispiel-Implementierung: Filtert die NodePositionList anhand der ausgewählten Filter
        if (NodePositionList == null)
        {
            FilteredPosList = Enumerable.Empty<NodePositionView>();
            return;
        }

        IEnumerable<NodePositionView> filtered = NodePositionList;

        if (_selectedFilter != null && _selectedFilter.Any())
        {
            filtered = filtered.Where(MatchesSelectedFilters);
        }

        FilteredPosList = filtered.ToList();
    }
}
